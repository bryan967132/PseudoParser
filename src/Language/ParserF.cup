/* 1. Package e importaciones */
package Language;
import java_cup.runtime.*;
import Painter.WordPainter;

/* 2. Codigo para el parser, variables y metodos */

parser code 
{:
    public ScannerF s;
    int index;
    int nIB = 0;
    WordPainter painter;
    public ParserF(ScannerF s,WordPainter painter) {
        super(s);
        this.s = s;
        this.painter = painter;
    }
    public void syntax_error(Symbol sym) {
        painter.SERROR(sym.left,sym.right);
    }
    public void unrecovered_syntax_error(Symbol sym) throws java.lang.Exception {}
:} 

/* 3. Terminales*/

terminal String RW_else, RW_elseif, RW_params, RW_incr, RW_equ, RW_endwhile, RW_endfunc, RW_endmeth, RW_endswitch;
terminal String RW_endfor, RW_endif, RW_println, RW_moreequ, RW_lessequ, RW_until, RW_to, RW_break, RW_start;
terminal String RW_print, RW_more, RW_less, RW_equequ, RW_notequ, RW_case, RW_or, RW_and, RW_not, RW_begin, RW_end;
terminal String RW_insert, RW_as, RW_then, RW_if, RW_switch, RW_do, RW_for, RW_while, RW_repeat, RW_return;
terminal String RW_meth, RW_func, RW_exec, RW_num, RW_str, RW_bool, RW_char, RW_pow, RW_mod, RW_true, RW_false;
terminal String TK_prompt, TK_plus, TK_minus, TK_uminus, TK_mult, TK_div, TK_lpar, TK_rpar, TK_comma;
terminal String TK_id, TK_num, TK_str, TK_char;

/* 4. No Terminales*/
non terminal String INI, INSTRUCTIONS, INSTRUCTION, MAIN_METHOD;
non terminal String INIT_ID, LIST_ID, TYPE, ID_ASIGN;
non terminal String EXP, IDS, CALLFUNC, ARGS;
non terminal String INST_IF, INST_FOR, INST_WHILE, INST_FUNC, INST_METH, INST_REPEAT;
non terminal String IF_STRUCT, ELSEIF_STRUCT, ELSE_STRUCT, SWITCH_STRUCT, CASE_BLOCK, CASE_LIST, CASE, DEFAULT;
non terminal String LOOP, FUNCTION, PARAMS, NATIVES_FUNCTION, BEGIN, INSTSGLOBAL, INSTGLOBAL;
non terminal String ARITHMETICS, RELATIONALS, LOGICS;
non terminal String IF, ELSE, ELSEIF, THEN, CASE1, FOR, TO, FNC, MTH, CALL, SWITCHCOLOR, COLORLPAR, COLORRPAR;

/* 5. Precedencias */
precedence left RW_or;
precedence left RW_and;
precedence right RW_not;
precedence left RW_equequ, RW_notequ;
precedence left RW_less, RW_lessequ, RW_more, RW_moreequ;
precedence left TK_plus, TK_minus;
precedence left TK_mult, TK_div, RW_mod;
precedence nonassoc RW_pow;
precedence right TK_uminus;

/* 6. Gramatica Libre de Contexto */

start with INI;

INI ::=
    BEGIN INSTSGLOBAL RW_end:c2 {:painter.RW3(c2left,c2right);:}    |
    BEGIN RW_end:c2 {:painter.RW3(c2left,c2right);:}                 ;

BEGIN ::= RW_begin:c1 {:painter.RW3(c1left,c1right);:} IDS:id {:painter.RW1(idleft,idright);:} ;

INSTSGLOBAL ::=
    INSTSGLOBAL INSTGLOBAL |
    INSTGLOBAL             ;

INSTGLOBAL ::=
    MAIN_METHOD |
    INIT_ID     |
    FUNCTION    |
    error       ;

INSTRUCTIONS ::=
    INSTRUCTIONS INSTRUCTION    |
    INSTRUCTION                 ;

INSTRUCTION ::=
    INIT_ID                         |
    ID_ASIGN                        |
    IF_STRUCT                       |
    SWITCH_STRUCT                   |
    LOOP                            |
    CALLFUNC                        |
    NATIVES_FUNCTION                |
    RW_break:d  {:painter.RW2(dleft,dright);:}     |
    RW_return:d {:painter.RW2(dleft,dright);:} EXP |
    error                           ;

MAIN_METHOD ::=
    RW_start:st {:painter.RW2(stleft,stright);:} CALLFUNC ;

INIT_ID ::=
    RW_insert:ins {:painter.RW1(insleft,insright);:} LIST_ID RW_as:a {:painter.RW2(aleft,aright);:} TYPE RW_equ:eq {:painter.RW2(eqleft,eqright);:} EXP ;

ID_ASIGN ::=
    LIST_ID:id {:painter.VARIABLE(idleft,idright);:} TK_prompt EXP ;

LIST_ID ::=
    LIST_ID TK_comma IDS:id {:painter.VARIABLE(idleft,idright);:} |
    IDS:id                  {:painter.VARIABLE(idleft,idright);:} ;

IF_STRUCT ::=
    IF EXP THEN INST_IF           |
    IF EXP THEN ELSEIF_STRUCT     |
    IF EXP THEN ELSE_STRUCT       ;

ELSEIF_STRUCT ::=
    INSTRUCTIONS ELSEIF EXP THEN ELSEIF_STRUCT    |
    ELSEIF EXP THEN ELSEIF_STRUCT                 |
    INSTRUCTIONS ELSEIF EXP THEN INST_IF          |
    ELSEIF EXP THEN INST_IF                       |
    INSTRUCTIONS ELSEIF EXP THEN ELSE_STRUCT      |
    ELSEIF EXP THEN ELSE_STRUCT                   ;

INST_IF ::=
    INSTRUCTIONS RW_endif:d  {:painter.RW2(dleft,dright);:} |
    RW_endif:d               {:painter.RW2(dleft,dright);:} ;

ELSE_STRUCT ::=
    INSTRUCTIONS ELSE INST_IF |
    ELSE INST_IF              ;


SWITCH_STRUCT ::=
    SWITCHCOLOR CASE_BLOCK RW_endswitch:ed {:painter.RW2(edleft,edright);:} |
    SWITCHCOLOR RW_endswitch:ed {:painter.RW2(edleft,edright);:} ;

SWITCHCOLOR ::=
    RW_switch:sw {:painter.RW2(swleft,swright);:} EXP RW_do:d {:painter.RW2(dleft,dright);:} ;

CASE_BLOCK ::=
    CASE_LIST DEFAULT |
    CASE_LIST         |
    DEFAULT           ;

CASE_LIST ::=
    CASE_LIST CASE |
    CASE           ;

CASE ::=
    CASE1 EXP THEN INSTRUCTIONS    |
    CASE1 EXP THEN                 ;

DEFAULT ::=
    ELSE THEN INSTRUCTIONS    |
    ELSE THEN                 ;

LOOP ::=
    FOR ID_ASIGN TO EXP RW_incr:inc {:painter.RW3(incleft,incright);:} EXP RW_do:d {:painter.RW2(dleft,dright);:} INST_FOR   |
    FOR ID_ASIGN TO EXP RW_do:d {:painter.RW2(dleft,dright);:} INST_FOR                                                      |
    RW_while:wh {:painter.RW2(whleft,whright);:} EXP RW_do:d {:painter.RW2(dleft,dright);:} INST_WHILE                       |
    INST_REPEAT RW_until:u {:painter.RW2(uleft,uright);:} EXP                                                                ;

INST_FOR ::=
    INSTRUCTIONS RW_endfor:ef {:painter.RW2(efleft,efright);:} |
    RW_endfor:ef              {:painter.RW2(efleft,efright);:} ;

INST_WHILE ::=
    INSTRUCTIONS RW_endwhile:ew {:painter.RW2(ewleft,ewright);:} |
    RW_endwhile:ew              {:painter.RW2(ewleft,ewright);:} ;

INST_REPEAT ::=
    RW_repeat:r {:painter.RW2(rleft,rright);:} INSTRUCTIONS |
    RW_repeat:r {:painter.RW2(rleft,rright);:}              ;

FUNCTION ::=
    FNC TYPE RW_params:p {:painter.RW4(pleft,pright);:} COLORLPAR PARAMS COLORRPAR:r INST_FUNC   |
    FNC TYPE INST_FUNC                                                                                                                                       |
    MTH RW_params:p {:painter.RW4(pleft,pright);:} COLORLPAR PARAMS COLORRPAR:r INST_METH        |
    MTH INST_METH                                                                                                                                            ;

FNC ::= RW_func:t {:painter.RW1(tleft,tright);:} IDS:id {:painter.FNC(idleft,idright);:} ;

MTH ::= RW_meth:t {:painter.RW1(tleft,tright);:} IDS:id {:painter.FNC(idleft,idright);:} ;

INST_FUNC ::=
    INSTRUCTIONS RW_endfunc:ef {:painter.RW1(efleft,efright);:} |
    RW_endfunc:ef              {:painter.RW1(efleft,efright);:} ;

INST_METH ::=
    INSTRUCTIONS RW_endmeth:ef {:painter.RW1(efleft,efright);:} |
    RW_endmeth:ef              {:painter.RW1(efleft,efright);:} ;

PARAMS ::=
    PARAMS TK_comma IDS:id {:painter.VARIABLE(idleft,idright);:} TYPE |
    IDS:id {:painter.VARIABLE(idleft,idright);:} TYPE                 ;

CALLFUNC ::=
    CALL COLORLPAR ARGS COLORRPAR |
    CALL COLORLPAR COLORRPAR      ;

CALL ::=
    RW_exec:ex {:painter.RW4(exleft,exright);:} IDS:id {:painter.FNC(idleft,idright);:} ;

ARGS ::=
    ARGS TK_comma EXP       |
    EXP                     ;

NATIVES_FUNCTION ::=
    RW_println:c {:painter.FNC(cleft,cright);:} EXP     |
    RW_print  :c {:painter.FNC(cleft,cright);:} EXP     ;

TYPE ::=
    RW_num :t {:painter.RW1(tleft,tright);:} |
    RW_str :t {:painter.RW1(tleft,tright);:} |
    RW_char:t {:painter.RW1(tleft,tright);:} |
    RW_bool:t {:painter.RW1(tleft,tright);:} ;

IDS ::=
    TK_id :id {:RESULT = id;:} |
    RW_or :id {:RESULT = id;:} |
    RW_and:id {:RESULT = id;:} ;

EXP ::=
    ARITHMETICS                                     |
    RELATIONALS                                     |
    LOGICS                                          |
    CALLFUNC                                        |
    TK_str  :p {:painter.STRING(pleft,pright);  :} |
    TK_char :p {:painter.CHAR(pleft,pright);    :} |
    TK_num  :p {:painter.NUMBER(pleft,pright);  :} |
    TK_id   :p {:painter.VARIABLE(pleft,pright);:} |
    RW_true :p {:painter.RW3(pleft,pright);     :} |
    RW_false:p {:painter.RW3(pleft,pright);     :} |
    COLORLPAR EXP COLORRPAR ;

ARITHMETICS ::=
    EXP TK_plus  EXP |
    EXP TK_minus EXP |
    EXP TK_mult  EXP |
    EXP TK_div   EXP |
    EXP RW_pow   EXP |
    EXP RW_mod   EXP |
    TK_minus     EXP %prec TK_uminus ;

RELATIONALS ::=
    EXP RW_equequ  EXP |
    EXP RW_notequ  EXP |
    EXP RW_lessequ EXP |
    EXP RW_moreequ EXP |
    EXP RW_less    EXP |
    EXP RW_more    EXP ;

LOGICS ::=
    EXP RW_and:o {:painter.RW4(oleft,oright);:} EXP |
    EXP RW_or:o  {:painter.RW4(oleft,oright);:} EXP |
    RW_not:o     {:painter.RW4(oleft,oright);:} EXP ;

IF ::= RW_if:ifr {:painter.RW2(ifrleft,ifrright);:} ;
ELSE ::= RW_else:el {:painter.RW2(elleft,elright);:} ;
THEN ::= RW_then:th {:painter.RW2(thleft,thright);:} ;
ELSEIF ::= RW_elseif:elif {:painter.RW2(elifleft,elifright);:} ;
CASE1 ::= RW_case:c {:painter.RW2(cleft,cright);:} ;
FOR ::= RW_for:f {:painter.RW2(fleft,fright);:};
TO ::= RW_to:t {:painter.RW3(tleft,tright);:} ;

COLORLPAR ::=
    TK_lpar :l {:painter.BRKT(nIB, lleft, lright); nIB ++;:} ;

COLORRPAR ::=
    TK_rpar :r {:nIB --; painter.BRKT(nIB, rleft, rright);:} ;